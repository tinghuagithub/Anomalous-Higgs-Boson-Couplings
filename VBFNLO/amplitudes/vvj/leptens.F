

      SUBROUTINE WPTOEPVEMUPMUMvirt(isig1,wem,wve,wmup,wmum,wemnugamom,wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C AND HELICITIES
C FOR THE POINT IN PHASE SPACE P(0:3,NEXTERNAL)
C  
C FOR PROCESS : w+ -> e+ ve mu+ mu-  
C  
C Crossing   1 is w+ e- -> ve mu+ mu-  
      IMPLICIT NONE
C  
C CONSTANTS
C  
      INTEGER    NGRAPHS,    NEIGEN 
      PARAMETER (NGRAPHS=   6,NEIGEN=  1) 
#include "genps.inc"
      INTEGER    NWAVEFUNCS     , NCOLOR
      PARAMETER (NWAVEFUNCS=  14, NCOLOR=   1) 
      double precision     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      double precision q(0:3),wemnugamom(0:3)

C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu,isig1

      double complex AMP(NGRAPHS), wcurr(0:3),wem(6),wve(6),wmum(6),wmup(6)
      double complex W(6,NWAVEFUNCS)

#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"

C ----------
C BEGIN CODE
C ----------
!       CALL IXXXXX(P(0,2   ),ZERO ,NHEL(2   ),-1*IC(2   ),W(1,2   ))        
!       CALL OXXXXX(P(0,3   ),ZERO ,NHEL(3   ),+1*IC(3   ),W(1,3   ))        
!       CALL IXXXXX(P(0,4   ),ZERO ,NHEL(4   ),-1*IC(4   ),W(1,4   ))        
!       CALL OXXXXX(P(0,5   ),ZERO ,NHEL(5   ),+1*IC(5   ),W(1,5   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=wmup(i)
      W(i,5)=wmum(i)
      enddo

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo

      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 

      CALL JIOXXX(W(1,2   ),W(1,3   ),GWF ,WMASS   ,WWIDTH  ,W(1,6   ))   
      if (.not.with_anom) then 
      CALL JVVXXX(W(1,1   ),W(1,6   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     7   ))                                                          
      elseif (with_anom) then
      CALL JVVXXX_anomwaj02(W(1,1   ),W(1,6   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     7   ))                                                          
      endif

      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,7   ),GAL ,AMP(1   )) 

      if (.not.with_anom) then           
      CALL JVVXXX(W(1,1   ),W(1,6   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     8   ))                 
      elseif (with_anom) then

      CALL JVVXXX_anomwzj2(W(1,1   ),W(1,6   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     8   ))                 
      endif
                                         
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,8   ),GZL ,AMP(2   ))            
      CALL FVIXXX(W(1,4   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,9   ))    
      CALL IOVXXX(W(1,9   ),W(1,5   ),W(1,6   ),GWF ,AMP(3   ))            
      CALL FVOXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,10  ))    
      CALL JIOXXX(W(1,2   ),W(1,10  ),GAL ,ZERO    ,ZERO    ,W(1,11  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,11  ),GAL ,AMP(4   ))            
      CALL JIOXXX(W(1,2   ),W(1,10  ),GZL ,ZMASS   ,ZWIDTH  ,W(1,12  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,12  ),GZL ,AMP(5   ))            
      CALL FVIXXX(W(1,2   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,13  ))    
      CALL JIOXXX(W(1,13  ),W(1,3   ),GZN ,ZMASS   ,ZWIDTH  ,W(1,14  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,14  ),GZL ,AMP(6   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)-AMP(   3)-AMP(   4)-AMP(   5)
     &             -AMP(   6)
      Enddo
      END


      SUBROUTINE WPTOEPVEMUPMUM(wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C FOR THE POINT WITH EXTERNAL LINES W(0:6,NEXTERNAL)
C  
C FOR PROCESS : w+ -> e+ ve mu+ mu-  
C  
      IMPLICIT NONE
C  
C CONSTANTS
C  
      INTEGER    NGRAPHS,    NEIGEN 
      PARAMETER (NGRAPHS=   6,NEIGEN=  1) 
#include "genps.inc"
      INTEGER    NWAVEFUNCS     , NCOLOR
      PARAMETER (NWAVEFUNCS=  14, NCOLOR=   1) 
      double precision     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      double precision q(0:3)

C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu
      double complex AMP(NGRAPHS), wcurr(0:3)
      double complex W(6,NWAVEFUNCS)
#include "tensorlep.inc"
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"
                                                                          
C ----------
C BEGIN CODE
C ----------
!       CALL IXXXXX(P(0,2   ),ZERO ,NHEL(2   ),-1*IC(2   ),W(1,2   ))        
!       CALL OXXXXX(P(0,3   ),ZERO ,NHEL(3   ),+1*IC(3   ),W(1,3   ))        
!       CALL IXXXXX(P(0,4   ),ZERO ,NHEL(4   ),-1*IC(4   ),W(1,4   ))        
!       CALL OXXXXX(P(0,5   ),ZERO ,NHEL(5   ),+1*IC(5   ),W(1,5   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=wmup(i)
      W(i,5)=wmum(i)
      enddo

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo

      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   ))

      CALL JIOXXX(W(1,2   ),W(1,3   ),GWF ,WMASS   ,WWIDTH  ,W(1,6   ))  

      if (.not.with_anom) then  
      CALL JVVXXX(W(1,1   ),W(1,6   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     7   ))                                                          
      elseif (with_anom) then
      CALL JVVXXX_anomwaj02(W(1,1   ),W(1,6   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     7   ))                                                          
      endif

      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,7   ),GAL ,AMP(1   ))            

      if (.not.with_anom) then  
      CALL JVVXXX(W(1,1   ),W(1,6   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     8   ))
      elseif (with_anom) then
      CALL JVVXXX_anomwzj2(W(1,1   ),W(1,6   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     8   ))
      endif
                                       
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,8   ),GZL ,AMP(2   ))            
      CALL FVIXXX(W(1,4   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,9   ))    
      CALL IOVXXX(W(1,9   ),W(1,5   ),W(1,6   ),GWF ,AMP(3   ))            
      CALL FVOXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,10  ))    
      CALL JIOXXX(W(1,2   ),W(1,10  ),GAL ,ZERO    ,ZERO    ,W(1,11  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,11  ),GAL ,AMP(4   ))            
      CALL JIOXXX(W(1,2   ),W(1,10  ),GZL ,ZMASS   ,ZWIDTH  ,W(1,12  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,12  ),GZL ,AMP(5   ))            
      CALL FVIXXX(W(1,2   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,13  ))    
      CALL JIOXXX(W(1,13  ),W(1,3   ),GZN ,ZMASS   ,ZWIDTH  ,W(1,14  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,14  ),GZL ,AMP(6   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)-AMP(   3)-AMP(   4)-AMP(   5)
     &             -AMP(   6)
      Enddo
      END


      SUBROUTINE WTOEVEMUPMUMvirt(isig1,wem,wve,wmum,wmup,wemnugamom,wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C FOR THE POINT WITH EXTERNAL LINES W(0:6,NEXTERNAL)
C  
C FOR PROCESS : w- -> e- ve~ mu+ mu-  
C  
      IMPLICIT NONE
C  
C CONSTANTS
C  
      INTEGER    NGRAPHS,    NEIGEN 
      PARAMETER (NGRAPHS=   6,NEIGEN=  1) 
#include "genps.inc"
      INTEGER    NWAVEFUNCS     , NCOLOR
      PARAMETER (NWAVEFUNCS=  14, NCOLOR=   1) 
      REAL*8     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      REAL*8 q(0:3),wemnugamom(0:3)

C  
C LOCAL VARIABLES 
C  
      INTEGER I,isig1,mu
      COMPLEX*16 AMP(NGRAPHS), wcurr(0:3),wem(6),wve(6),wmum(6),wmup(6)
      COMPLEX*16 W(6,NWAVEFUNCS)
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"
                                                                          
C ----------
C BEGIN CODE
C ----------
!      CALL OXXXXX(P(0,2   ),ZERO ,NHEL(2   ),+1*IC(2   ),W(1,2   ))        
!      CALL IXXXXX(P(0,3   ),ZERO ,NHEL(3   ),-1*IC(3   ),W(1,3   ))        
!      CALL IXXXXX(P(0,4   ),ZERO ,NHEL(4   ),-1*IC(4   ),W(1,4   ))        
!      CALL OXXXXX(P(0,5   ),ZERO ,NHEL(5   ),+1*IC(5   ),W(1,5   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=wmup(i)
      W(i,5)=wmum(i)
      enddo

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo

      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 
       
      CALL JIOXXX(W(1,3   ),W(1,2   ),GWF ,WMASS   ,WWIDTH  ,W(1,6   ))    
      CALL FVIXXX(W(1,4   ),W(1,6   ),GWF ,ZERO    ,ZERO    ,W(1,7   ))    
      CALL IOVXXX(W(1,7   ),W(1,5   ),W(1,1   ),GWF ,AMP(1   ))
!
      if (.not.with_anom) then
      CALL JVVXXX(W(1,6   ),W(1,1   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     8   ))                                                          
!
      elseif (with_anom) then
      CALL JVVXXX_anomwaj0(W(1,6   ),W(1,1   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     8   ))                                                          
      endif
!
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,8   ),GAL ,AMP(2   )) 
!
      if (.not.with_anom) then
      CALL JVVXXX(W(1,6   ),W(1,1   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     9   ))                 
      elseif (with_anom) then
      CALL JVVXXX_anomwzj(W(1,6   ),W(1,1   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     9   ))                 
      endif
!
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,9   ),GZL ,AMP(3   ))            
      CALL FVIXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,10  ))    
      CALL JIOXXX(W(1,10  ),W(1,2   ),GAL ,ZERO    ,ZERO    ,W(1,11  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,11  ),GAL ,AMP(4   ))            
      CALL JIOXXX(W(1,10  ),W(1,2   ),GZL ,ZMASS   ,ZWIDTH  ,W(1,12  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,12  ),GZL ,AMP(5   ))            
      CALL FVOXXX(W(1,2   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,13  ))    
      CALL JIOXXX(W(1,3   ),W(1,13  ),GZN ,ZMASS   ,ZWIDTH  ,W(1,14  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,14  ),GZL ,AMP(6   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)-AMP(   3)-AMP(   4)-AMP(   5)
     &             -AMP(   6)
      Enddo
      END


      SUBROUTINE WTOEVEMUPMUM(wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C FOR THE POINT WITH EXTERNAL LINES W(0:6,NEXTERNAL)
C  
C FOR PROCESS : w- -> e- ve~ mu+ mu-  
C  
      IMPLICIT NONE
C  
C CONSTANTS
C  
      INTEGER    NGRAPHS,    NEIGEN 
      PARAMETER (NGRAPHS=   6,NEIGEN=  1) 
#include "genps.inc"
      INTEGER    NWAVEFUNCS     , NCOLOR
      PARAMETER (NWAVEFUNCS=  14, NCOLOR=   1) 
      REAL*8     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      REAL*8 q(0:3)

C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu
      COMPLEX*16 AMP(NGRAPHS), wcurr(0:3)
      COMPLEX*16 W(6,NWAVEFUNCS)
#include "tensorlep.inc"
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"

                                                                          
C ----------
C BEGIN CODE
C ----------
!      CALL OXXXXX(P(0,2   ),ZERO ,NHEL(2   ),+1*IC(2   ),W(1,2   ))        
!      CALL IXXXXX(P(0,3   ),ZERO ,NHEL(3   ),-1*IC(3   ),W(1,3   ))        
!      CALL IXXXXX(P(0,4   ),ZERO ,NHEL(4   ),-1*IC(4   ),W(1,4   ))        
!      CALL OXXXXX(P(0,5   ),ZERO ,NHEL(5   ),+1*IC(5   ),W(1,5   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=wmup(i)
      W(i,5)=wmum(i)
      enddo

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo

      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 
       
      CALL JIOXXX(W(1,3   ),W(1,2   ),GWF ,WMASS   ,WWIDTH  ,W(1,6   ))    
      CALL FVIXXX(W(1,4   ),W(1,6   ),GWF ,ZERO    ,ZERO    ,W(1,7   ))    
      CALL IOVXXX(W(1,7   ),W(1,5   ),W(1,1   ),GWF ,AMP(1   ))            
!
      if (.not.with_anom) then
      CALL JVVXXX(W(1,6   ),W(1,1   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     8   ))                                                          
!
      elseif (with_anom) then
      CALL JVVXXX_anomwaj0(W(1,6   ),W(1,1   ),GWWA ,ZERO    ,ZERO    ,W(1,         
     &     8   ))                                                          
      endif

!
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,8   ),GAL ,AMP(2   )) 
!
      if (.not.with_anom) then
      CALL JVVXXX(W(1,6   ),W(1,1   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     9   ))                 
      elseif (with_anom) then
      CALL JVVXXX_anomwzj(W(1,6   ),W(1,1   ),GWWZ ,ZMASS   ,ZWIDTH  ,W(1,         
     &     9   ))                 
      endif
!
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,9   ),GZL ,AMP(3   ))            
      CALL FVIXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,10  ))    
      CALL JIOXXX(W(1,10  ),W(1,2   ),GAL ,ZERO    ,ZERO    ,W(1,11  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,11  ),GAL ,AMP(4   ))            
      CALL JIOXXX(W(1,10  ),W(1,2   ),GZL ,ZMASS   ,ZWIDTH  ,W(1,12  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,12  ),GZL ,AMP(5   ))            
      CALL FVOXXX(W(1,2   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,13  ))    
      CALL JIOXXX(W(1,3   ),W(1,13  ),GZN ,ZMASS   ,ZWIDTH  ,W(1,14  ))    
      CALL IOVXXX(W(1,4   ),W(1,5   ),W(1,14  ),GZL ,AMP(6   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)-AMP(   3)-AMP(   4)-AMP(   5)
     &             -AMP(   6)
      Enddo
      END


      SUBROUTINE SWTOEPVEA(isig1,wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C AND HELICITIES
C FOR THE POINT IN PHASE SPACE P(0:3,NEXTERNAL)
C  
C FOR PROCESS : w+ -> e+ ve a  
C  
C Crossing   1 is w+ e- -> ve a  
      IMPLICIT NONE
      INTEGER    NGRAPHS   
      PARAMETER (NGRAPHS=   21) 
      INTEGER    NWAVEFUNCS     
      PARAMETER (NWAVEFUNCS=   6) 
      double precision     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      double precision Q(0:3)
C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu,isig1
      double complex AMP(NGRAPHS),wcurr(0:3)
      double complex W(6,NWAVEFUNCS)
#include "tensorlep.inc"
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"
C                                                                          
C ----------
C BEGIN CODE
C ----------

!       CALL IXXXXX(P(0,2   ),ZERO ,NHEL(2   ),-1*IC(2   ),W(1,2   ))        
!       CALL OXXXXX(P(0,3   ),ZERO ,NHEL(3   ),+1*IC(3   ),W(1,3   ))        
!       CALL VXXXXX(P(0,4   ),ZERO ,NHEL(4   ),+1*IC(4   ),W(1,4   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=waf(i,isig1)
      enddo      

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo
      
      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 
      
      CALL JIOXXX(W(1,2   ),W(1,3   ),GWF ,WMASS   ,WWIDTH  ,W(1,5   ))
      if (.not.with_anom) then
      CALL VVVXXX(W(1,1   ),W(1,5   ),W(1,4   ),GWWA ,AMP(1   ))
      elseif (with_anom) then
      CALL VVVXXX_anomwaj2(W(1,1   ),W(1,5   ),W(1,4   ),GWWA ,AMP(1   ))
      endif
      CALL FVOXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,6   ))    
      CALL IOVXXX(W(1,2   ),W(1,6   ),W(1,4   ),GAL ,AMP(2   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)

      Enddo
      END


      SUBROUTINE SWTOEPVEAvirt(isig1,wem,wve,waf,wemnugamom,wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C AND HELICITIES
C FOR THE POINT IN PHASE SPACE P(0:3,NEXTERNAL)
C  
C FOR PROCESS : w+ -> e+ ve a  
C  
C Crossing   1 is w+ e- -> ve a  
      implicit none
      INTEGER    NGRAPHS,    NEIGEN 
      PARAMETER (NGRAPHS=   2,NEIGEN=  1) 
#include "genps.inc"
      INTEGER    NWAVEFUNCS     , NCOLOR
      PARAMETER (NWAVEFUNCS=   6, NCOLOR=   1) 
      REAL*8     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      double precision Q(0:3),wemnugamom(0:3)
C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu,isig1
      double complex AMP(NGRAPHS),wcurr(0:3),waf(6),wem(6),wve(6)
      double complex W(6,NWAVEFUNCS)
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"

C ----------
C BEGIN CODE
C ----------
!       CALL IXXXXX(P(0,2   ),ZERO ,NHEL(2   ),-1*IC(2   ),W(1,2   ))        
!       CALL OXXXXX(P(0,3   ),ZERO ,NHEL(3   ),+1*IC(3   ),W(1,3   ))        
!       CALL VXXXXX(P(0,4   ),ZERO ,NHEL(4   ),+1*IC(4   ),W(1,4   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=waf(i)
      enddo      

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo
      
      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 

      CALL JIOXXX(W(1,2   ),W(1,3   ),GWF ,WMASS   ,WWIDTH  ,W(1,5   ))
      if (.not.with_anom) then
      CALL VVVXXX(W(1,1   ),W(1,5   ),W(1,4   ),GWWA ,AMP(1   )) 
      elseif(with_anom) then
      CALL VVVXXX_anomwaj2(W(1,1   ),W(1,5   ),W(1,4   ),GWWA ,AMP(1   )) 
      endif  
      CALL FVOXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,6   ))    
      CALL IOVXXX(W(1,2   ),W(1,6   ),W(1,4   ),GAL ,AMP(2   ))            
      wcurr(mu) = -AMP(   1)-AMP(   2)
     
      enddo
      END


      SUBROUTINE SWTOEVEA(isig1,wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C AND HELICITIES
C FOR THE POINT IN PHASE SPACE P(0:3,NEXTERNAL)
C  
C FOR PROCESS : w- -> e- ve~ a  
C  
C Crossing   1 is w- e+ -> ve~ a  
      implicit none
      INTEGER    NGRAPHS   
      PARAMETER (NGRAPHS=   21) 
      INTEGER    NWAVEFUNCS     
      PARAMETER (NWAVEFUNCS=   6) 
      double precision     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      double precision Q(0:3)
C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu,isig1
      double complex AMP(NGRAPHS),wcurr(0:3)
      double complex W(6,NWAVEFUNCS)
#include "tensorlep.inc"
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"


C ----------
C BEGIN CODE
C ----------
!       CALL OXXXXX(P(0,2   ),ZERO ,NHEL(2   ),+1*IC(2   ),W(1,2   ))        
!       CALL IXXXXX(P(0,3   ),ZERO ,NHEL(3   ),-1*IC(3   ),W(1,3   ))        
!       CALL VXXXXX(P(0,4   ),ZERO ,NHEL(4   ),+1*IC(4   ),W(1,4   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=waf(i,isig1)
      enddo      

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo
      
      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 

      CALL JIOXXX(W(1,3   ),W(1,2   ),GWF ,WMASS   ,WWIDTH  ,W(1,5   ))
      if (.not.with_anom) then    
      CALL VVVXXX(W(1,5   ),W(1,1   ),W(1,4   ),GWWA ,AMP(1   ))
      elseif (with_anom) then
      CALL VVVXXX_anomwaj(W(1,5   ),W(1,1   ),W(1,4   ),GWWA ,AMP(1   ))
      endif           
      CALL FVIXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,6   ))    
      CALL IOVXXX(W(1,6   ),W(1,2   ),W(1,4   ),GAL ,AMP(2   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)

      Enddo
      END


      SUBROUTINE SWTOEVEAvirt(isig1,wem,wve,waf,wemnugamom,wcurr)
C  
C Generated by MadGraph II Version 3.0. Updated 02/19/04                
C RETURNS AMPLITUDE SQUARED SUMMED/AVG OVER COLORS
C AND HELICITIES
C FOR THE POINT IN PHASE SPACE P(0:3,NEXTERNAL)
C  
C FOR PROCESS : w- -> e- ve~ a  
C  
C Crossing   1 is w- e+ -> ve~ a  
      implicit none
      INTEGER    NGRAPHS   
      PARAMETER (NGRAPHS=   21) 
      INTEGER    NWAVEFUNCS     
      PARAMETER (NWAVEFUNCS=   6) 
      double precision     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      double precision Q(0:3),wemnugamom(0:3)
C  
C LOCAL VARIABLES 
C  
      INTEGER I,mu,isig1
      double complex AMP(NGRAPHS),wcurr(0:3),waf(6),wem(6),wve(6)
      double complex W(6,NWAVEFUNCS)
#include "VBFNLO/utilities/coupl.inc"
#include "VBFNLO/utilities/global.inc"

C ----------
C BEGIN CODE
C ----------
!       CALL OXXXXX(P(0,2   ),ZERO ,NHEL(2   ),+1*IC(2   ),W(1,2   ))        
!       CALL IXXXXX(P(0,3   ),ZERO ,NHEL(3   ),-1*IC(3   ),W(1,3   ))        
!       CALL VXXXXX(P(0,4   ),ZERO ,NHEL(4   ),+1*IC(4   ),W(1,4   ))        

      do i=1,6
      W(i,2)=wem(i)
      W(i,3)=wve(i)
      W(i,4)=waf(i)
      enddo      

      do mu=0,3 
      q(mu)=wemnugamom(mu)
      enddo
      
      do mu=0,3

      CALL VCARTX(Q,WMASS ,WWIDTH,mu,-1,W(1,1   )) 

      CALL JIOXXX(W(1,3   ),W(1,2   ),GWF ,WMASS   ,WWIDTH  ,W(1,5   ))
      if (.not.with_anom) then        
      CALL VVVXXX(W(1,5   ),W(1,1   ),W(1,4   ),GWWA ,AMP(1   )) 
      elseif (with_anom) then   
      CALL VVVXXX_anomwaj(W(1,5   ),W(1,1   ),W(1,4   ),GWWA ,AMP(1   )) 
      endif          
      CALL FVIXXX(W(1,3   ),W(1,1   ),GWF ,ZERO    ,ZERO    ,W(1,6   ))    
      CALL IOVXXX(W(1,6   ),W(1,2   ),W(1,4   ),GAL ,AMP(2   ))            
      wcurr(   mu) = -AMP(   1)-AMP(   2)

      Enddo

      END


      subroutine vvvxxx_anomwaj(wm,wp,w3,g , vertex)

c
c This subroutine computes an amplitude of the three-point coupling of
c the gauge bosons.
c
c input:
c       complex wm(6)          : vector               flow-out W-
c       complex wp(6)          : vector               flow-out W+
c       complex w3(6)          : vector               j3 or A    or Z
c       real    g              : coupling constant    gw or gwwa or gwwz
c
c output:
c       complex vertex         : amplitude               gamma(wm,wp,w3)
c     
      implicit none
      double complex wm(6),wp(6),w3(6),vertex,vertexnsm,
     &     xv1,xv2,xv3,v12,v23,v31,p12,p13,p21,p23,p31,p32,psq,v1k,v3k,v2k1,v2k2,
     &     k(0:3),k1(0:3),k2(0:3),v1(0:3),v2(0:3),v3(0:3),dotcc
      double precision pwm(0:3),pwp(0:3),pw3(0:3),g,wgam2,momwga(0:3)
      integer mu
      external dotcc

      double precision rZero, rTenth
      parameter( rZero = 0.0d0, rTenth = 0.1d0 )

      double precision formfactorkappaA, formfactorlambda

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

c
      pwm(0) = dble( wm(5))
      pwm(1) = dble( wm(6))
      pwm(2) = dimag(wm(6))
      pwm(3) = dimag(wm(5))
      pwp(0) = dble( wp(5))
      pwp(1) = dble( wp(6))
      pwp(2) = dimag(wp(6))
      pwp(3) = dimag(wp(5))
      pw3(0) = dble( w3(5))
      pw3(1) = dble( w3(6))
      pw3(2) = dimag(w3(6))
      pw3(3) = dimag(w3(5))

      do mu=0,3
      k(mu)=dcmplx(pwm(mu))
      k1(mu)=dcmplx(pwp(mu))
      k2(mu)=dcmplx(pw3(mu))
      v1(mu)=wm(mu+1)
      v2(mu)=wp(mu+1)
      v3(mu)=w3(mu+1)
      enddo

      formfactorkappaA=1d0
      formfactorlambda=1d0
      
      if(formfact) then

         do mu=0,3
            momwga(mu)=pwm(mu)+pw3(mu)
         enddo
         wgam2=momwga(0)**2-(momwga(1)**2+momwga(2)**2+momwga(3)**2)
         
         if (trianom .eq. 1) then
            formfactorkappaA = ((FB_0/(1d0+wgam2/
     -           massscale2FB)**ffexpFB) + (FW_0/(1d0+wgam2/
     -           massscale2FW)**ffexpFW))/(FB_0+FW_0)
         else if (trianom .eq. 2) then
            formfactorkappaA = 1d0/(1d0+wgam2/
     -           massscale2KA)**ffexpKA
         end if
         formfactorlambda=1d0/(1d0+wgam2/massscale2L)**ffexpL

      endif

      aDkappa0=-aDkappa0_0*formfactorkappaA
      lambda0=lambda0_0*formfactorlambda
         
      v12 = wm(1)*wp(1)-wm(2)*wp(2)-wm(3)*wp(3)-wm(4)*wp(4)
      v23 = wp(1)*w3(1)-wp(2)*w3(2)-wp(3)*w3(3)-wp(4)*w3(4)
      v31 = w3(1)*wm(1)-w3(2)*wm(2)-w3(3)*wm(3)-w3(4)*wm(4)
      xv1 = rZero
      xv2 = rZero
      xv3 = rZero

      v1k= wm(1)*pwp(0)-wm(2)*pwp(1)-wm(3)*pwp(2)-wm(4)*pwp(3)
      v3k= w3(1)*pwp(0)-w3(2)*pwp(1)-w3(3)*pwp(2)-w3(4)*pwp(3)
      v2k1= wp(1)*pwm(0)-wp(2)*pwm(1)-wp(3)*pwm(2)-wp(4)*pwm(3)
      v2k2= wp(1)*pw3(0)-wp(2)*pw3(1)-wp(3)*pw3(2)-wp(4)*pw3(3)


      if ( abs(wm(1)).ne.rZero ) then
         if ( abs(wm(1)).ge.max(abs(wm(2)),abs(wm(3)),abs(wm(4)))
     &        *rTenth )
     &      xv1 = pwm(0)/wm(1)
      endif
      if ( abs(wp(1)).ne.rZero) then
         if ( abs(wp(1)).ge.max(abs(wp(2)),abs(wp(3)),abs(wp(4)))
     &        *rTenth )
     &      xv2 = pwp(0)/wp(1)
      endif
      if ( abs(w3(1)).ne.rZero) then
         if ( abs(w3(1)).ge.max(abs(w3(2)),abs(w3(3)),abs(w3(4)))
     &        *rTenth )
     &      xv3 = pw3(0)/w3(1)
      endif

      p12 = (pwm(0)-xv1*wm(1))*wp(1)-(pwm(1)-xv1*wm(2))*wp(2)
     &     -(pwm(2)-xv1*wm(3))*wp(3)-(pwm(3)-xv1*wm(4))*wp(4)
      p13 = (pwm(0)-xv1*wm(1))*w3(1)-(pwm(1)-xv1*wm(2))*w3(2)
     &     -(pwm(2)-xv1*wm(3))*w3(3)-(pwm(3)-xv1*wm(4))*w3(4)
      p21 = (pwp(0)-xv2*wp(1))*wm(1)-(pwp(1)-xv2*wp(2))*wm(2)
     &     -(pwp(2)-xv2*wp(3))*wm(3)-(pwp(3)-xv2*wp(4))*wm(4)
      p23 = (pwp(0)-xv2*wp(1))*w3(1)-(pwp(1)-xv2*wp(2))*w3(2)
     &     -(pwp(2)-xv2*wp(3))*w3(3)-(pwp(3)-xv2*wp(4))*w3(4)
      p31 = (pw3(0)-xv3*w3(1))*wm(1)-(pw3(1)-xv3*w3(2))*wm(2)
     &     -(pw3(2)-xv3*w3(3))*wm(3)-(pw3(3)-xv3*w3(4))*wm(4)
      p32 = (pw3(0)-xv3*w3(1))*wp(1)-(pw3(1)-xv3*w3(2))*wp(2)
     &     -(pw3(2)-xv3*w3(3))*wp(3)-(pw3(3)-xv3*w3(4))*wp(4)

      psq=(pwp(0)**2-pwp(1)**2-pwp(2)**2-pwp(3)**2)


      vertexnsm= (lambda0*dotcc(k,v2)*dotcc(k1,v3)*dotcc(k2,v1))
     $     /MW2 -(lambda0*dotcc(k,v3)*dotcc(k1,v1)*dotcc(k2
     $     ,v2))/MW2 - dotcc(k,v3)*dotcc(v1,v2) +(lambda0
     $     *dotcc(k,v3)*dotcc(k1,k2)*dotcc(v1,v2))/MW2 +
     $     dotcc(k1,v3)*dotcc(v1,v2) -(lambda0*dotcc(k,k2)*dotcc(k1
     $     ,v3)*dotcc(v1,v2))/MW2 +dotcc(k,v2)*dotcc(v1,v3) -
     $     (lambda0*dotcc(k,v2)*dotcc(k1,k2)*dotcc(v1,v3))/MW2
     $     -dotcc(k2,v2)*dotcc(v1,v3) +aDkappa0*dotcc(k2,v2)
     $     *dotcc(v1,v3) + (lambda0*dotcc(k,k1)*dotcc(k2,v2)*dotcc(v1
     $     ,v3))/MW2 -dotcc(k1,v1)*dotcc(v2,v3) +(lambda0
     $     *dotcc(k,k2)*dotcc(k1,v1)*dotcc(v2,v3))/MW2 +
     $     dotcc(k2,v1)*dotcc(v2,v3) -aDkappa0*dotcc(k2,v1)
     $     *dotcc(v2,v3) -(lambda0*dotcc(k,k1)*dotcc(k2,v1)*dotcc(v2
     $     ,v3))/MW2

 
      vertex = -(v12*(p13-p23)+v23*(p21-p31)+v31*(p32-p12))*g


      vertex = vertexnsm*g


c
      return
      end


      subroutine vvvxxx_anomwaj2(wm,wp,w3,g , vertex)

c
c This subroutine computes an amplitude of the three-point coupling of
c the gauge bosons.
c
c input:
c       complex wm(6)          : vector               flow-out W-
c       complex wp(6)          : vector               flow-out W+
c       complex w3(6)          : vector               j3 or A    or Z
c       real    g              : coupling constant    gw or gwwa or gwwz
c
c output:
c       complex vertex         : amplitude               gamma(wm,wp,w3)
c     
      implicit none
      double complex wm(6),wp(6),w3(6),vertex,vertexnsm,
     &     xv1,xv2,xv3,v12,v23,v31,p12,p13,p21,p23,p31,p32,psq,v1k,v3k,v2k1,v2k2,
     &     k(0:3),k1(0:3),k2(0:3),v1(0:3),v2(0:3),v3(0:3),dotcc
      double precision pwm(0:3),pwp(0:3),pw3(0:3),g,wgam2,momwga(0:3)
      integer mu
      external dotcc

      double precision rZero, rTenth
      parameter( rZero = 0.0d0, rTenth = 0.1d0 )

      double precision formfactorkappaA, formfactorlambda

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

c
      pwm(0) = dble( wm(5))
      pwm(1) = dble( wm(6))
      pwm(2) = dimag(wm(6))
      pwm(3) = dimag(wm(5))
      pwp(0) = dble( wp(5))
      pwp(1) = dble( wp(6))
      pwp(2) = dimag(wp(6))
      pwp(3) = dimag(wp(5))
      pw3(0) = dble( w3(5))
      pw3(1) = dble( w3(6))
      pw3(2) = dimag(w3(6))
      pw3(3) = dimag(w3(5))

      do mu=0,3
      k(mu)=dcmplx(pwm(mu))
      k1(mu)=dcmplx(pwp(mu))
      k2(mu)=dcmplx(pw3(mu))
      v1(mu)=wm(mu+1)
      v2(mu)=wp(mu+1)
      v3(mu)=w3(mu+1)
      enddo

      formfactorkappaA=1d0
      formfactorlambda=1d0

      if(formfact) then

      do mu=0,3
      momwga(mu)=pwp(mu)+pw3(mu)
      enddo
      wgam2=momwga(0)**2-(momwga(1)**2+momwga(2)**2+momwga(3)**2)

      if (trianom .eq. 1) then
         formfactorkappaA = ((FB_0/(1d0+wgam2/
     -        massscale2FB)**ffexpFB) + (FW_0/(1d0+wgam2/
     -        massscale2FW)**ffexpFW))/(FB_0+FW_0)
      else if (trianom .eq. 2) then
         formfactorkappaA = 1d0/(1d0+wgam2/
     -        massscale2KA)**ffexpKA
      end if
      formfactorlambda=1d0/(1d0+wgam2/massscale2L)**ffexpL

      endif

      aDkappa0=-aDkappa0_0*formfactorkappaA
      lambda0=lambda0_0*formfactorlambda
         
      v12 = wm(1)*wp(1)-wm(2)*wp(2)-wm(3)*wp(3)-wm(4)*wp(4)
      v23 = wp(1)*w3(1)-wp(2)*w3(2)-wp(3)*w3(3)-wp(4)*w3(4)
      v31 = w3(1)*wm(1)-w3(2)*wm(2)-w3(3)*wm(3)-w3(4)*wm(4)
      xv1 = rZero
      xv2 = rZero
      xv3 = rZero

      v1k= wm(1)*pwp(0)-wm(2)*pwp(1)-wm(3)*pwp(2)-wm(4)*pwp(3)
      v3k= w3(1)*pwp(0)-w3(2)*pwp(1)-w3(3)*pwp(2)-w3(4)*pwp(3)
      v2k1= wp(1)*pwm(0)-wp(2)*pwm(1)-wp(3)*pwm(2)-wp(4)*pwm(3)
      v2k2= wp(1)*pw3(0)-wp(2)*pw3(1)-wp(3)*pw3(2)-wp(4)*pw3(3)


      if ( abs(wm(1)).ne.rZero ) then
         if ( abs(wm(1)).ge.max(abs(wm(2)),abs(wm(3)),abs(wm(4)))
     &        *rTenth )
     &      xv1 = pwm(0)/wm(1)
      endif
      if ( abs(wp(1)).ne.rZero) then
         if ( abs(wp(1)).ge.max(abs(wp(2)),abs(wp(3)),abs(wp(4)))
     &        *rTenth )
     &      xv2 = pwp(0)/wp(1)
      endif
      if ( abs(w3(1)).ne.rZero) then
         if ( abs(w3(1)).ge.max(abs(w3(2)),abs(w3(3)),abs(w3(4)))
     &        *rTenth )
     &      xv3 = pw3(0)/w3(1)
      endif

      p12 = (pwm(0)-xv1*wm(1))*wp(1)-(pwm(1)-xv1*wm(2))*wp(2)
     &     -(pwm(2)-xv1*wm(3))*wp(3)-(pwm(3)-xv1*wm(4))*wp(4)
      p13 = (pwm(0)-xv1*wm(1))*w3(1)-(pwm(1)-xv1*wm(2))*w3(2)
     &     -(pwm(2)-xv1*wm(3))*w3(3)-(pwm(3)-xv1*wm(4))*w3(4)
      p21 = (pwp(0)-xv2*wp(1))*wm(1)-(pwp(1)-xv2*wp(2))*wm(2)
     &     -(pwp(2)-xv2*wp(3))*wm(3)-(pwp(3)-xv2*wp(4))*wm(4)
      p23 = (pwp(0)-xv2*wp(1))*w3(1)-(pwp(1)-xv2*wp(2))*w3(2)
     &     -(pwp(2)-xv2*wp(3))*w3(3)-(pwp(3)-xv2*wp(4))*w3(4)
      p31 = (pw3(0)-xv3*w3(1))*wm(1)-(pw3(1)-xv3*w3(2))*wm(2)
     &     -(pw3(2)-xv3*w3(3))*wm(3)-(pw3(3)-xv3*w3(4))*wm(4)
      p32 = (pw3(0)-xv3*w3(1))*wp(1)-(pw3(1)-xv3*w3(2))*wp(2)
     &     -(pw3(2)-xv3*w3(3))*wp(3)-(pw3(3)-xv3*w3(4))*wp(4)

      psq=(pwp(0)**2-pwp(1)**2-pwp(2)**2-pwp(3)**2)


      vertexnsm= (lambda0*dotcc(k,v2)*dotcc(k1,v3)*dotcc(k2,v1))
     $     /MW2 -(lambda0*dotcc(k,v3)*dotcc(k1,v1)*dotcc(k2
     $     ,v2))/MW2 - dotcc(k,v3)*dotcc(v1,v2) +(lambda0
     $     *dotcc(k,v3)*dotcc(k1,k2)*dotcc(v1,v2))/MW2 +
     $     dotcc(k1,v3)*dotcc(v1,v2) -(lambda0*dotcc(k,k2)*dotcc(k1
     $     ,v3)*dotcc(v1,v2))/MW2 +dotcc(k,v2)*dotcc(v1,v3) -
     $     (lambda0*dotcc(k,v2)*dotcc(k1,k2)*dotcc(v1,v3))/MW2
     $     -dotcc(k2,v2)*dotcc(v1,v3) +aDkappa0*dotcc(k2,v2)
     $     *dotcc(v1,v3) + (lambda0*dotcc(k,k1)*dotcc(k2,v2)*dotcc(v1
     $     ,v3))/MW2 -dotcc(k1,v1)*dotcc(v2,v3) +(lambda0
     $     *dotcc(k,k2)*dotcc(k1,v1)*dotcc(v2,v3))/MW2 +
     $     dotcc(k2,v1)*dotcc(v2,v3) -aDkappa0*dotcc(k2,v1)
     $     *dotcc(v2,v3) -(lambda0*dotcc(k,k1)*dotcc(k2,v1)*dotcc(v2
     $     ,v3))/MW2

 
      vertex = -(v12*(p13-p23)+v23*(p21-p31)+v31*(p32-p12))*g


      vertex = vertexnsm*g


c
      return
      end


      subroutine jvvxxx_anomwaj2(v1,v2,g,vmass,vwidth , jvv)
c
c This subroutine computes an off-shell vector current from the three-
c point gauge boson coupling.  The vector propagator is given in Feynman
c gauge for a massless vector and in unitary gauge for a massive vector.
c
c input:
c       complex v1(6)          : first  vector                        v1
c       complex v2(6)          : second vector                        v2
c       real    g              : coupling constant (see the table below)
c       real    vmass          : mass  of output vector v
c       real    vwidth         : width of output vector v
c
c the possible sets of the inputs are as follows:
c    ------------------------------------------------------------------
c    |   v1   |   v2   |  jvv   |      g       |   vmass  |  vwidth   |
c    ------------------------------------------------------------------
c    |   W-   |   W+   |  A/Z   |  gwwa/gwwz   | 0./zmass | 0./zwidth |
c    | W3/A/Z |   W-   |  W+    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    |   W+   | W3/A/Z |  W-    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    ------------------------------------------------------------------
c where all the bosons are defined by the flowing-OUT quantum number.
c
c output:
c       complex jvv(6)         : vector current            j^mu(v:v1,v2)
c     
      implicit none
      integer mu
      double complex v1(6),v2(6),jvv(6),j12(0:3),j12t(0:3),js,dg,v1t(0:3),v2t(0:3),
     &    k(0:3),k1(0:3),k2(0:3),jst
      double complex sv1,sv2,s11,s12,s21,s22,v12,dotcc

      double complex cm2        ! mass**2- I Gamma mass (Fabio)
      double precision p1(0:3),p2(0:3),q(0:3),g,vmass,vwidth,s,wgam2
      double precision vm2,m1,m2

      double precision rZero
      parameter( rZero = 0.0d0 )
      external dotcc 

      double precision formfactorkappaA, formfactorlambda

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

      jvv(5) = v1(5)+v2(5)
      jvv(6) = v1(6)+v2(6)

      p1(0) =  dble( v1(5))
      p1(1) =  dble( v1(6))
      p1(2) =  dimag(v1(6))
      p1(3) =  dimag(v1(5))
      p2(0) =  dble( v2(5))
      p2(1) =  dble( v2(6))
      p2(2) =  dimag(v2(6))
      p2(3) =  dimag(v2(5))
      q(0)  = -dble( jvv(5))
      q(1)  = -dble( jvv(6))
      q(2)  = -dimag(jvv(6))
      q(3)  = -dimag(jvv(5))
      s = q(0)**2-(q(1)**2+q(2)**2+q(3)**2)
      vm2 = vmass**2

      wgam2=p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
c      print*, dsqrt(wgam2)
c      print*, ""

!      print*, "naomal",p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)


      formfactorkappaA=1d0
      formfactorlambda=1d0

      if(formfact) then

      wgam2=p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
c      print*, dsqrt(wgam2)
c      print*, ""


      if (trianom .eq. 1) then
         formfactorkappaA = ((FB_0/(1d0+wgam2/
     -        massscale2FB)**ffexpFB) + (FW_0/(1d0+wgam2/
     -        massscale2FW)**ffexpFW))/(FB_0+FW_0)
      else if (trianom .eq. 2) then
         formfactorkappaA = 1d0/(1d0+wgam2/
     -        massscale2KA)**ffexpKA
      end if
      formfactorlambda=1d0/(1d0+wgam2/massscale2L)**ffexpL

      endif

      aDkappa0=-aDkappa0_0*formfactorkappaA
      lambda0=lambda0_0*formfactorlambda

      v12 = v1(1)*v2(1)-v1(2)*v2(2)-v1(3)*v2(3)-v1(4)*v2(4)
      sv1 =   (p2(0)-q(0))*v1(1) -(p2(1)-q(1))*v1(2)
     &      - (p2(2)-q(2))*v1(3) -(p2(3)-q(3))*v1(4)
      sv2 = - (p1(0)-q(0))*v2(1) +(p1(1)-q(1))*v2(2)
     &      + (p1(2)-q(2))*v2(3) +(p1(3)-q(3))*v2(4)
      j12(0) = (p1(0)-p2(0))*v12 +sv1*v2(1) +sv2*v1(1)
      j12(1) = (p1(1)-p2(1))*v12 +sv1*v2(2) +sv2*v1(2)
      j12(2) = (p1(2)-p2(2))*v12 +sv1*v2(3) +sv2*v1(3)
      j12(3) = (p1(3)-p2(3))*v12 +sv1*v2(4) +sv2*v1(4)

      do mu=0,3
      v1t(mu)=v1(mu+1)
      v2t(mu)=v2(mu+1)
      k(mu)=dcmplx(p1(mu))
      k2(mu)=dcmplx(p2(mu))
      k1(mu)=dcmplx(q(mu))
      enddo


      do mu=0,3

         j12t(mu)=(lambda0*dotcc(k1,v2t)*dotcc(k2,v1t)*k(mu))/
     $        MW2 + dotcc(v1t,v2t)*k(mu) - (lambda0* dotcc(k1
     $        ,k2)*dotcc(v1t,v2t)*k(mu))/MW2 - (lambda0
     $        *dotcc(k,v2t)*dotcc(k1,v1t)*k2(mu))/MW2 -
     $        dotcc(v1t,v2t)*k2(mu) + aDkappa0*dotcc(v1t,v2t)*
     $        k2(mu) + (lambda0*dotcc(k,k1)*dotcc(v1t,v2t)*k2(mu))/
     $        MW2 - dotcc(k,v2t)*v1t(mu) + (lambda0* dotcc(k
     $        ,v2t)*dotcc(k1,k2)*v1t(mu))/MW2 + dotcc(k1,v2t)
     $        *v1t(mu) - (lambda0*dotcc(k,k2)* dotcc(k1,v2t)*v1t(mu))
     $        /MW2 - dotcc(k1,v1t)* v2t(mu) + (lambda0*dotcc(k
     $        ,k2)*dotcc(k1,v1t)*v2t(mu))/ MW2 + dotcc(k2,v1t)
     $        *v2t(mu) - aDkappa0* dotcc(k2,v1t)*v2t(mu) -
     $        (lambda0*dotcc(k,k1)* dotcc(k2,v1t)*v2t(mu))/MW2
        
c         print*, j12t(mu), j12(mu)
      enddo
c         print*, lambda0, aDkappa0
c      print*, " "

      if ( vmass.ne.rZero ) then


         m1 = p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
         m2 = p2(0)**2-(p2(1)**2+p2(2)**2+p2(3)**2)
         s11 = p1(0)*v1(1)-p1(1)*v1(2)-p1(2)*v1(3)-p1(3)*v1(4)
         s12 = p1(0)*v2(1)-p1(1)*v2(2)-p1(2)*v2(3)-p1(3)*v2(4)
         s21 = p2(0)*v1(1)-p2(1)*v1(2)-p2(2)*v1(3)-p2(3)*v1(4)
         s22 = p2(0)*v2(1)-p2(1)*v2(2)-p2(2)*v2(3)-p2(3)*v2(4)
c     Fabio's implementation of the fixed width
         cm2=dcmplx( vm2, -vmass*vwidth )
c     js = (v12*(-m1+m2) +s11*s12 -s21*s22)/vm2
         js = (v12*(-m1+m2) +s11*s12 -s21*s22)/cm2
        
! does not matter because of proportionality to momentum, and dirac equation

         jst=  -(dotcc(k,v2t)*dotcc(k1,v1t)) + dotcc(k1,v2t)*dotcc(k2
     $        ,v1t) - aDkappa0*dotcc(k1,v2t)*dotcc(k2,v1t) +dotcc(k
     $        ,k1)*dotcc(v1t,v2t) - dotcc(k1,k2)*dotcc(v1t,v2t) +
     $        aDkappa0*dotcc(k1,k2)*dotcc(v1t,v2t)

         jst=jst/cm2
         
         dg = -g/dcmplx( s-vm2, vmass*vwidth )

c  For the running width, use below instead of the above dg.
c         dg = -g/dcmplx( s-vm2, max(vwidth*s/vmass,rZero) )

         jvv(1) = -dg*(j12t(0)-q(0)*jst)
         jvv(2) = -dg*(j12t(1)-q(1)*jst)
         jvv(3) = -dg*(j12t(2)-q(2)*jst)
         jvv(4) = -dg*(j12t(3)-q(3)*jst)

!      else
!
!         gs = -g/s
!
!         jvv(1) = gs*j12t(0)
!         jvv(2) = gs*j12t(1)
!         jvv(3) = gs*j12t(2)
!         jvv(4) = gs*j12t(3)

      end if
c
      return
      end


      subroutine jvvxxx_anomwaj(v1,v2,g,vmass,vwidth , jvv)
c
c This subroutine computes an off-shell vector current from the three-
c point gauge boson coupling.  The vector propagator is given in Feynman
c gauge for a massless vector and in unitary gauge for a massive vector.
c
c input:
c       complex v1(6)          : first  vector                        v1
c       complex v2(6)          : second vector                        v2
c       real    g              : coupling constant (see the table below)
c       real    vmass          : mass  of output vector v
c       real    vwidth         : width of output vector v
c
c the possible sets of the inputs are as follows:
c    ------------------------------------------------------------------
c    |   v1   |   v2   |  jvv   |      g       |   vmass  |  vwidth   |
c    ------------------------------------------------------------------
c    |   W-   |   W+   |  A/Z   |  gwwa/gwwz   | 0./zmass | 0./zwidth |
c    | W3/A/Z |   W-   |  W+    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    |   W+   | W3/A/Z |  W-    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    ------------------------------------------------------------------
c where all the bosons are defined by the flowing-OUT quantum number.
c
c output:
c       complex jvv(6)         : vector current            j^mu(v:v1,v2)
c     
      implicit none
      integer mu
      double complex v1(6),v2(6),jvv(6),j12(0:3),j12t(0:3),js,dg,v1t(0:3),v2t(0:3),
     &    k(0:3),k1(0:3),k2(0:3),jst
      double complex sv1,sv2,s11,s12,s21,s22,v12,dotcc
      double complex cm2        ! mass**2- I Gamma mass (Fabio)
      double precision p1(0:3),p2(0:3),q(0:3),g,vmass,vwidth,s,wgam2
      double precision vm2,m1,m2

      double precision rZero
      parameter( rZero = 0.0d0 )
      external dotcc 

      double precision formfactorkappaA, formfactorlambda

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

      jvv(5) = v1(5)+v2(5)
      jvv(6) = v1(6)+v2(6)

      p1(0) =  dble( v1(5))
      p1(1) =  dble( v1(6))
      p1(2) =  dimag(v1(6))
      p1(3) =  dimag(v1(5))
      p2(0) =  dble( v2(5))
      p2(1) =  dble( v2(6))
      p2(2) =  dimag(v2(6))
      p2(3) =  dimag(v2(5))
      q(0)  = -dble( jvv(5))
      q(1)  = -dble( jvv(6))
      q(2)  = -dimag(jvv(6))
      q(3)  = -dimag(jvv(5))
      s = q(0)**2-(q(1)**2+q(2)**2+q(3)**2)
      vm2 = vmass**2

      wgam2=p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
c      print*, dsqrt(wgam2)
c      print*, ""

!      print*, "naomal",p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)

      formfactorkappaA=1d0
      formfactorlambda=1d0

      if(formfact) then

      wgam2=p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
c      print*, dsqrt(wgam2)
c      print*, ""


      if (trianom .eq. 1) then
         formfactorkappaA = ((FB_0/(1d0+wgam2/
     -        massscale2FB)**ffexpFB) + (FW_0/(1d0+wgam2/
     -        massscale2FW)**ffexpFW))/(FB_0+FW_0)
      else if (trianom .eq. 2) then
         formfactorkappaA = 1d0/(1d0+wgam2/
     -        massscale2KA)**ffexpKA
      end if
      formfactorlambda=1d0/(1d0+wgam2/massscale2L)**ffexpL

      endif

      aDkappa0=-aDkappa0_0*formfactorkappaA
      lambda0=lambda0_0*formfactorlambda

      v12 = v1(1)*v2(1)-v1(2)*v2(2)-v1(3)*v2(3)-v1(4)*v2(4)
      sv1 =   (p2(0)-q(0))*v1(1) -(p2(1)-q(1))*v1(2)
     &      - (p2(2)-q(2))*v1(3) -(p2(3)-q(3))*v1(4)
      sv2 = - (p1(0)-q(0))*v2(1) +(p1(1)-q(1))*v2(2)
     &      + (p1(2)-q(2))*v2(3) +(p1(3)-q(3))*v2(4)
      j12(0) = (p1(0)-p2(0))*v12 +sv1*v2(1) +sv2*v1(1)
      j12(1) = (p1(1)-p2(1))*v12 +sv1*v2(2) +sv2*v1(2)
      j12(2) = (p1(2)-p2(2))*v12 +sv1*v2(3) +sv2*v1(3)
      j12(3) = (p1(3)-p2(3))*v12 +sv1*v2(4) +sv2*v1(4)

      do mu=0,3
      v1t(mu)=v1(mu+1)
      v2t(mu)=v2(mu+1)
      k(mu)=dcmplx(p1(mu))
      k2(mu)=dcmplx(p2(mu))
      k1(mu)=dcmplx(q(mu))
      enddo

      do mu=0,3

         j12t(mu)=(lambda0*dotcc(k1,v2t)*dotcc(k2,v1t)*k(mu))/
     $        MW2 + dotcc(v1t,v2t)*k(mu) - (lambda0* dotcc(k1
     $        ,k2)*dotcc(v1t,v2t)*k(mu))/MW2 - (lambda0
     $        *dotcc(k,v2t)*dotcc(k1,v1t)*k2(mu))/MW2 -
     $        dotcc(v1t,v2t)*k2(mu) + aDkappa0*dotcc(v1t,v2t)*
     $        k2(mu) + (lambda0*dotcc(k,k1)*dotcc(v1t,v2t)*k2(mu))/
     $        MW2 - dotcc(k,v2t)*v1t(mu) + (lambda0* dotcc(k
     $        ,v2t)*dotcc(k1,k2)*v1t(mu))/MW2 + dotcc(k1,v2t)
     $        *v1t(mu) - (lambda0*dotcc(k,k2)* dotcc(k1,v2t)*v1t(mu))
     $        /MW2 - dotcc(k1,v1t)* v2t(mu) + (lambda0*dotcc(k
     $        ,k2)*dotcc(k1,v1t)*v2t(mu))/ MW2 + dotcc(k2,v1t)
     $        *v2t(mu) - aDkappa0* dotcc(k2,v1t)*v2t(mu) -
     $        (lambda0*dotcc(k,k1)* dotcc(k2,v1t)*v2t(mu))/MW2
        
c         print*, j12t(mu), j12(mu)
      enddo
c         print*, lambda0, aDkappa0
c      print*, " "

      if ( vmass.ne.rZero ) then


         m1 = p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
         m2 = p2(0)**2-(p2(1)**2+p2(2)**2+p2(3)**2)
         s11 = p1(0)*v1(1)-p1(1)*v1(2)-p1(2)*v1(3)-p1(3)*v1(4)
         s12 = p1(0)*v2(1)-p1(1)*v2(2)-p1(2)*v2(3)-p1(3)*v2(4)
         s21 = p2(0)*v1(1)-p2(1)*v1(2)-p2(2)*v1(3)-p2(3)*v1(4)
         s22 = p2(0)*v2(1)-p2(1)*v2(2)-p2(2)*v2(3)-p2(3)*v2(4)
c     Fabio's implementation of the fixed width
         cm2=dcmplx( vm2, -vmass*vwidth )
c     js = (v12*(-m1+m2) +s11*s12 -s21*s22)/vm2
         js = (v12*(-m1+m2) +s11*s12 -s21*s22)/cm2
        
! does not matter because of proportionality to momentum, and dirac equation

         jst=  -(dotcc(k,v2t)*dotcc(k1,v1t)) + dotcc(k1,v2t)*dotcc(k2
     $        ,v1t) - aDkappa0*dotcc(k1,v2t)*dotcc(k2,v1t) +dotcc(k
     $        ,k1)*dotcc(v1t,v2t) - dotcc(k1,k2)*dotcc(v1t,v2t) +
     $        aDkappa0*dotcc(k1,k2)*dotcc(v1t,v2t)

         jst=jst/cm2
         
         dg = -g/dcmplx( s-vm2, vmass*vwidth )

c  For the running width, use below instead of the above dg.
c         dg = -g/dcmplx( s-vm2, max(vwidth*s/vmass,rZero) )

         jvv(1) = dg*(j12t(0)-q(0)*jst)
         jvv(2) = dg*(j12t(1)-q(1)*jst)
         jvv(3) = dg*(j12t(2)-q(2)*jst)
         jvv(4) = dg*(j12t(3)-q(3)*jst)

!      else
!
!         gs = -g/s
!
!         jvv(1) = gs*j12t(0)
!         jvv(2) = gs*j12t(1)
!         jvv(3) = gs*j12t(2)
!         jvv(4) = gs*j12t(3)

      end if
c
      return
      end


      subroutine jvvxxx_anomwzj(v1,v2,g,vmass,vwidth , jvv)
c
c This subroutine computes an off-shell vector current from the three-
c point gauge boson coupling.  The vector propagator is given in Feynman
c gauge for a massless vector and in unitary gauge for a massive vector.
c
c input:
c       complex v1(6)          : first  vector                        v1
c       complex v2(6)          : second vector                        v2
c       real    g              : coupling constant (see the table below)
c       real    vmass          : mass  of output vector v
c       real    vwidth         : width of output vector v
c
c the possible sets of the inputs are as follows:
c    ------------------------------------------------------------------
c    |   v1   |   v2   |  jvv   |      g       |   vmass  |  vwidth   |
c    ------------------------------------------------------------------
c    |   W-   |   W+   |  A/Z   |  gwwa/gwwz   | 0./zmass | 0./zwidth |
c    | W3/A/Z |   W-   |  W+    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    |   W+   | W3/A/Z |  W-    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    ------------------------------------------------------------------
c where all the bosons are defined by the flowing-OUT quantum number.
c
c output:
c       complex jvv(6)         : vector current            j^mu(v:v1,v2)
c     
      implicit none
      integer mu,nu
      double complex v1(6),v2(6),jvv(6),j12(0:3),j12t(0:3),js,dg,v1t(0:3),
     &    k(0:3),k1(0:3),k2(0:3),jst,v3t(0:3)
      double complex sv1,sv2,s11,s12,s21,s22,v12,dotcc
      double complex cm2        ! mass**2- I Gamma mass (Fabio)
      double precision p1(0:3),p2(0:3),q(0:3),g,vmass,vwidth,gs,s,wgam2,onepg
      double precision vm2,m1,m2,gappl,kappa

      double precision rZero
      parameter( rZero = 0.0d0 )
      external dotcc 

      double precision formfactorkappaz, formfactorlambdaz, formfactorgz

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

      jvv(5) = v1(5)+v2(5)
      jvv(6) = v1(6)+v2(6)

      p1(0) =  dble( v1(5))
      p1(1) =  dble( v1(6))
      p1(2) =  dimag(v1(6))
      p1(3) =  dimag(v1(5))
      p2(0) =  dble( v2(5))
      p2(1) =  dble( v2(6))
      p2(2) =  dimag(v2(6))
      p2(3) =  dimag(v2(5))
      q(0)  = -dble( jvv(5))
      q(1)  = -dble( jvv(6))
      q(2)  = -dimag(jvv(6))
      q(3)  = -dimag(jvv(5))
      s = q(0)**2-(q(1)**2+q(2)**2+q(3)**2)
      vm2 = vmass**2


      formfactorkappaz=1d0
      formfactorlambdaz=1d0
      formfactorgz=1d0

      if(formfact) then

!      W(p2)->W(p1),gamma(nu)
         wgam2=p2(0)**2-(p2(1)**2+p2(2)**2+p2(3)**2)
         
         if (trianom .eq. 1) then
            formfactorkappaz = ((-SW2*FB_0/(1d0+wgam2/
     -           massscale2FB)**ffexpFB) + (CW2*FW_0/(1d0+wgam2/
     -           massscale2FW)**ffexpFW))/(CW2*FW_0-SW2*FB_0)
         else if (trianom .eq. 2) then
            formfactorkappaz=1d0/(1d0+wgam2/
     -           massscale2KZ)**ffexpKZ
         end if

         formfactorlambdaz=1d0/(1d0+wgam2/
     -        massscale2L)**ffexpL
         formfactorgz=1d0/(1d0+wgam2/massscale2G)**ffexpG
         
      endif  ! end of formfactor inclusion

      zDg0=zDg0_0*formfactorgz
      onepg=1d0+zDg0
      gappl=g*onepg

      zDkappa0=zDkappa0_0*formfactorkappaz
      kappa=1d0+zDkappa0
      lambda0=lambda0_0*formfactorlambdaz

      kappa=kappa/onepg
      lambda0=lambda0/onepg

      v12 = v1(1)*v2(1)-v1(2)*v2(2)-v1(3)*v2(3)-v1(4)*v2(4)
      sv1 =   (p2(0)-q(0))*v1(1) -(p2(1)-q(1))*v1(2)
     &      - (p2(2)-q(2))*v1(3) -(p2(3)-q(3))*v1(4)
      sv2 = - (p1(0)-q(0))*v2(1) +(p1(1)-q(1))*v2(2)
     &      + (p1(2)-q(2))*v2(3) +(p1(3)-q(3))*v2(4)
      j12(0) = (p1(0)-p2(0))*v12 +sv1*v2(1) +sv2*v1(1)
      j12(1) = (p1(1)-p2(1))*v12 +sv1*v2(2) +sv2*v1(2)
      j12(2) = (p1(2)-p2(2))*v12 +sv1*v2(3) +sv2*v1(3)
      j12(3) = (p1(3)-p2(3))*v12 +sv1*v2(4) +sv2*v1(4)

      do mu=0,3
      v1t(mu)=v2(mu+1)
      v3t(mu)=v1(mu+1)
      k(mu)=dcmplx(p2(mu))
      k1(mu)=dcmplx(p1(mu)) !!!! attention
      k2(mu)=dcmplx(q(mu))  !!!! attention
      enddo

      do nu=0,3


         j12t(nu)=(lambda0*dotcc(k,v3t)*dotcc(k2,v1t)*k1(nu) +
     $        dotcc(v1t,v3t)*((-MW2 + lambda0*dotcc(k1,k2))
     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*k1(nu)) +
     $        MW2*dotcc(k,v3t)*v1t(nu) -lambda0*dotcc(k,v3t)
     $        *dotcc(k1,k2)*v1t(nu) - kappa*MW2*dotcc(k2,v3t)
     $        *v1t(nu) + lambda0*dotcc(k,k1)*dotcc(k2,v3t)*v1t(nu)
     $        +kappa*MW2*dotcc(k2,v1t)*v3t(nu) - lambda0
     $        *dotcc(k,k1)*dotcc(k2,v1t)*v3t(nu) -dotcc(k1,v1t)
     $        *(lambda0*dotcc(k2,v3t)*k(nu) + (MW2 -
     $        lambda0*dotcc(k,k2))*v3t(nu)))/MW2

      enddo

      if ( vmass.ne.rZero ) then

!   .true. in wz, however dirac equation!

         m1 = p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
         m2 = p2(0)**2-(p2(1)**2+p2(2)**2+p2(3)**2)
         s11 = p1(0)*v1(1)-p1(1)*v1(2)-p1(2)*v1(3)-p1(3)*v1(4)
         s12 = p1(0)*v2(1)-p1(1)*v2(2)-p1(2)*v2(3)-p1(3)*v2(4)
         s21 = p2(0)*v1(1)-p2(1)*v1(2)-p2(2)*v1(3)-p2(3)*v1(4)
         s22 = p2(0)*v2(1)-p2(1)*v2(2)-p2(2)*v2(3)-p2(3)*v2(4)
c     Fabio's implementation of the fixed width
         cm2=dcmplx( vm2, -vmass*vwidth )
c      js = (v12*(-m1+m2) +s11*s12 -s21*s22)/vm2
         js = (v12*(-m1+m2) +s11*s12 -s21*s22)/cm2


         jst=dotcc(j12t,k2)/cm2

         dg = -gappl/dcmplx( s-vm2, vmass*vwidth )


c  For the running width, use below instead of the above dg.
c         dg = -g/dcmplx( s-vm2, max(vwidth*s/vmass,rZero) )

         jvv(1) = dg*(j12t(0)-q(0)*jst)
         jvv(2) = dg*(j12t(1)-q(1)*jst)
         jvv(3) = dg*(j12t(2)-q(2)*jst)
         jvv(4) = dg*(j12t(3)-q(3)*jst)

      else

         gs = -gappl/s

         jvv(1) = gs*j12t(0)
         jvv(2) = gs*j12t(1)
         jvv(3) = gs*j12t(2)
         jvv(4) = gs*j12t(3)

      end if
c
      return
      end


      subroutine jvvxxx_anomwzj2(v1,v2,g,vmass,vwidth , jvv)
c
c This subroutine computes an off-shell vector current from the three-
c point gauge boson coupling.  The vector propagator is given in Feynman
c gauge for a massless vector and in unitary gauge for a massive vector.
c
c input:
c       complex v1(6)          : first  vector                        v1
c       complex v2(6)          : second vector                        v2
c       real    g              : coupling constant (see the table below)
c       real    vmass          : mass  of output vector v
c       real    vwidth         : width of output vector v
c
c the possible sets of the inputs are as follows:
c    ------------------------------------------------------------------
c    |   v1   |   v2   |  jvv   |      g       |   vmass  |  vwidth   |
c    ------------------------------------------------------------------
c    |   W-   |   W+   |  A/Z   |  gwwa/gwwz   | 0./zmass | 0./zwidth |
c    | W3/A/Z |   W-   |  W+    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    |   W+   | W3/A/Z |  W-    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    ------------------------------------------------------------------
c where all the bosons are defined by the flowing-OUT quantum number.
c
c output:
c       complex jvv(6)         : vector current            j^mu(v:v1,v2)
c     
      implicit none
      integer mu,nu
      double complex v1(6),v2(6),jvv(6),j12(0:3),j12t(0:3),js,dg,v1t(0:3),
     &    k(0:3),k1(0:3),k2(0:3),jst,v3t(0:3)
      double complex sv1,sv2,s11,s12,s21,s22,v12,dotcc
      double complex cm2        ! mass**2- I Gamma mass (Fabio)
      double precision p1(0:3),p2(0:3),q(0:3),g,vmass,vwidth,gs,s,wgam2,onepg
      double precision vm2,m1,m2,gappl,kappa

      double precision rZero
      parameter( rZero = 0.0d0 )
      external dotcc 

      double precision formfactorkappaz, formfactorlambdaz, formfactorgz

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

      jvv(5) = v1(5)+v2(5)
      jvv(6) = v1(6)+v2(6)

      p1(0) =  dble( v1(5))
      p1(1) =  dble( v1(6))
      p1(2) =  dimag(v1(6))
      p1(3) =  dimag(v1(5))
      p2(0) =  dble( v2(5))
      p2(1) =  dble( v2(6))
      p2(2) =  dimag(v2(6))
      p2(3) =  dimag(v2(5))
      q(0)  = -dble( jvv(5))
      q(1)  = -dble( jvv(6))
      q(2)  = -dimag(jvv(6))
      q(3)  = -dimag(jvv(5))
      s = q(0)**2-(q(1)**2+q(2)**2+q(3)**2)
      vm2 = vmass**2

      formfactorkappaz=1d0
      formfactorlambdaz=1d0
      formfactorgz=1d0

      if(formfact) then

!      W(p1)->W(p2),gamma(nu)
         wgam2=p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
         
         if (trianom .eq. 1) then
            formfactorkappaz = ((-SW2*FB_0/(1d0+wgam2/
     -           massscale2FB)**ffexpFB) + (CW2*FW_0/(1d0+wgam2/
     -           massscale2FW)**ffexpFW))/(CW2*FW_0-SW2*FB_0)
         else if (trianom .eq. 2) then
            formfactorkappaz=1d0/(1d0+wgam2/
     -           massscale2KZ)**ffexpKZ
         end if

         formfactorlambdaz=1d0/(1d0+wgam2/
     -        massscale2L)**ffexpL
         formfactorgz=1d0/(1d0+wgam2/massscale2G)**ffexpG
         
      endif  ! end of formfactor inclusion

      zDkappa0=zDkappa0_0*formfactorkappaz
      kappa=1d0+zDkappa0
      lambda0=lambda0_0*formfactorlambdaz
      zDg0=zDg0_0*formfactorgz

      onepg=1d0+zDg0
      gappl=g*onepg

      kappa=kappa/onepg
      lambda0=lambda0/onepg

      v12 = v1(1)*v2(1)-v1(2)*v2(2)-v1(3)*v2(3)-v1(4)*v2(4)
      sv1 =   (p2(0)-q(0))*v1(1) -(p2(1)-q(1))*v1(2)
     &      - (p2(2)-q(2))*v1(3) -(p2(3)-q(3))*v1(4)
      sv2 = - (p1(0)-q(0))*v2(1) +(p1(1)-q(1))*v2(2)
     &      + (p1(2)-q(2))*v2(3) +(p1(3)-q(3))*v2(4)
      j12(0) = (p1(0)-p2(0))*v12 +sv1*v2(1) +sv2*v1(1)
      j12(1) = (p1(1)-p2(1))*v12 +sv1*v2(2) +sv2*v1(2)
      j12(2) = (p1(2)-p2(2))*v12 +sv1*v2(3) +sv2*v1(3)
      j12(3) = (p1(3)-p2(3))*v12 +sv1*v2(4) +sv2*v1(4)

      do mu=0,3
      v1t(mu)=v2(mu+1)
      v3t(mu)=v1(mu+1)
      k(mu)=dcmplx(p2(mu))
      k1(mu)=dcmplx(p1(mu)) !!!! attention
      k2(mu)=dcmplx(q(mu))  !!!! attention
      enddo


      do nu=0,3
        
         j12t(nu)=(lambda0*dotcc(k,v3t)*dotcc(k2,v1t)*k1(nu) +
     $        dotcc(v1t,v3t)*((-MW2 + lambda0*dotcc(k1,k2))
     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*k1(nu)) +
     $        MW2*dotcc(k,v3t)*v1t(nu) -lambda0*dotcc(k,v3t)
     $        *dotcc(k1,k2)*v1t(nu) - kappa*MW2*dotcc(k2,v3t)
     $        *v1t(nu) + lambda0*dotcc(k,k1)*dotcc(k2,v3t)*v1t(nu)
     $        +kappa*MW2*dotcc(k2,v1t)*v3t(nu) - lambda0
     $        *dotcc(k,k1)*dotcc(k2,v1t)*v3t(nu) -dotcc(k1,v1t)
     $        *(lambda0*dotcc(k2,v3t)*k(nu) + (MW2 -
     $        lambda0*dotcc(k,k2))*v3t(nu)))/MW2

c         j12t(nu)=(lambda0*dotcc(k,v3t)*dotcc(k2,v1t)*k1(nu) +
c     $        dotcc(v1t,v3t)*((-MW2 + lambda0*dotcc(k1,k2))
c     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*k1(nu)) +
c     $        MW2*dotcc(k,v3t)*v1t(nu) -lambda0*dotcc(k,v3t)
c     $        *dotcc(k1,k2)*v1t(nu) - 2*MW2*dotcc(k2,v3t)
c     $        *v1t(nu) + kappa*MW2*dotcc(k2,v3t)*v1t(nu)
c     $        +lambda0*dotcc(k,k1)*dotcc(k2,v3t)*v1t(nu) + 2
c     $        *MW2*dotcc(k2,v1t)*v3t(nu) - kappa*MW2
c     $        *dotcc(k2,v1t)*v3t(nu) -lambda0*dotcc(k,k1)*dotcc(k2
c     $        ,v1t)*v3t(nu) - dotcc(k1,v1t)*(lambda0*dotcc(k2,v3t)
c     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*v3t(nu)))
c     $        /MW2


      enddo

      if ( vmass.ne.rZero ) then

!   .true. in wz, however dirac equation!

         m1 = p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
         m2 = p2(0)**2-(p2(1)**2+p2(2)**2+p2(3)**2)
         s11 = p1(0)*v1(1)-p1(1)*v1(2)-p1(2)*v1(3)-p1(3)*v1(4)
         s12 = p1(0)*v2(1)-p1(1)*v2(2)-p1(2)*v2(3)-p1(3)*v2(4)
         s21 = p2(0)*v1(1)-p2(1)*v1(2)-p2(2)*v1(3)-p2(3)*v1(4)
         s22 = p2(0)*v2(1)-p2(1)*v2(2)-p2(2)*v2(3)-p2(3)*v2(4)
c     Fabio's implementation of the fixed width
         cm2=dcmplx( vm2, -vmass*vwidth )
c      js = (v12*(-m1+m2) +s11*s12 -s21*s22)/vm2
         js = (v12*(-m1+m2) +s11*s12 -s21*s22)/cm2

         jst=dotcc(j12t,k2)/cm2

         dg = -gappl/dcmplx( s-vm2, vmass*vwidth )

c  For the running width, use below instead of the above dg.
c         dg = -g/dcmplx( s-vm2, max(vwidth*s/vmass,rZero) )

         jvv(1) = dg*(j12t(0)-q(0)*jst)
         jvv(2) = dg*(j12t(1)-q(1)*jst)
         jvv(3) = dg*(j12t(2)-q(2)*jst)
         jvv(4) = dg*(j12t(3)-q(3)*jst)

      else

         gs = -gappl/s

         jvv(1) = gs*j12t(0)
         jvv(2) = gs*j12t(1)
         jvv(3) = gs*j12t(2)
         jvv(4) = gs*j12t(3)

      end if
c
      return
      end


      subroutine jvvxxx_anomwaj0(v1,v2,g,vmass,vwidth , jvv)
c
c This subroutine computes an off-shell vector current from the three-
c point gauge boson coupling.  The vector propagator is given in Feynman
c gauge for a massless vector and in unitary gauge for a massive vector.
c
c input:
c       complex v1(6)          : first  vector                        v1
c       complex v2(6)          : second vector                        v2
c       real    g              : coupling constant (see the table below)
c       real    vmass          : mass  of output vector v
c       real    vwidth         : width of output vector v
c
c the possible sets of the inputs are as follows:
c    ------------------------------------------------------------------
c    |   v1   |   v2   |  jvv   |      g       |   vmass  |  vwidth   |
c    ------------------------------------------------------------------
c    |   W-   |   W+   |  A/Z   |  gwwa/gwwz   | 0./zmass | 0./zwidth |
c    | W3/A/Z |   W-   |  W+    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    |   W+   | W3/A/Z |  W-    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    ------------------------------------------------------------------
c where all the bosons are defined by the flowing-OUT quantum number.
c
c output:
c       complex jvv(6)         : vector current            j^mu(v:v1,v2)
c     
      implicit none
      integer mu,nu
      double complex v1(6),v2(6),jvv(6),j12(0:3),j12t(0:3),v1t(0:3),
     &    k(0:3),k1(0:3),k2(0:3),v3t(0:3)
      double complex sv1,sv2,v12,dotcc
      double complex cm2        ! mass**2- I Gamma mass (Fabio)
      double precision p1(0:3),p2(0:3),q(0:3),g,vmass,vwidth,gs,s,wgam2
      double precision vm2

      double precision rZero
      parameter( rZero = 0.0d0 )
      external dotcc 

      double precision formfactorkappaA, formfactorlambda

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

      jvv(5) = v1(5)+v2(5)
      jvv(6) = v1(6)+v2(6)

      p1(0) =  dble( v1(5))
      p1(1) =  dble( v1(6))
      p1(2) =  dimag(v1(6))
      p1(3) =  dimag(v1(5))
      p2(0) =  dble( v2(5))
      p2(1) =  dble( v2(6))
      p2(2) =  dimag(v2(6))
      p2(3) =  dimag(v2(5))
      q(0)  = -dble( jvv(5))
      q(1)  = -dble( jvv(6))
      q(2)  = -dimag(jvv(6))
      q(3)  = -dimag(jvv(5))
      s = q(0)**2-(q(1)**2+q(2)**2+q(3)**2)
      vm2 = vmass**2


!      print*, "naomal",p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)


      formfactorkappaA=1d0
      formfactorlambda=1d0

      if(formfact) then

!     W(p2) -> W(p1) gamma(nu)

         wgam2=p2(0)**2-(p2(1)**2+p2(2)**2+p2(3)**2)
         
         formfactorlambda=1d0/(1d0+wgam2/massscale2L)**ffexpL
         if (trianom .eq. 1) then
            formfactorkappaA = ((FB_0/(1d0+wgam2/
     -           massscale2FB)**ffexpFB) + (FW_0/(1d0+wgam2/
     -           massscale2FW)**ffexpFW))/(FB_0+FW_0)
         else if (trianom .eq. 2) then
            formfactorkappaA = 1d0/(1d0+wgam2/
     -           massscale2KA)**ffexpKA
         end if

      endif

      aDkappa0=-aDkappa0_0*formfactorkappaA
      lambda0=lambda0_0*formfactorlambda

      v12 = v1(1)*v2(1)-v1(2)*v2(2)-v1(3)*v2(3)-v1(4)*v2(4)
      sv1 =   (p2(0)-q(0))*v1(1) -(p2(1)-q(1))*v1(2)
     &      - (p2(2)-q(2))*v1(3) -(p2(3)-q(3))*v1(4)
      sv2 = - (p1(0)-q(0))*v2(1) +(p1(1)-q(1))*v2(2)
     &      + (p1(2)-q(2))*v2(3) +(p1(3)-q(3))*v2(4)
      j12(0) = (p1(0)-p2(0))*v12 +sv1*v2(1) +sv2*v1(1)
      j12(1) = (p1(1)-p2(1))*v12 +sv1*v2(2) +sv2*v1(2)
      j12(2) = (p1(2)-p2(2))*v12 +sv1*v2(3) +sv2*v1(3)
      j12(3) = (p1(3)-p2(3))*v12 +sv1*v2(4) +sv2*v1(4)

      do mu=0,3
      v1t(mu)=v2(mu+1)
      v3t(mu)=v1(mu+1)
      k(mu)=dcmplx(p2(mu))
      k1(mu)=dcmplx(p1(mu)) !!!! attention
      k2(mu)=dcmplx(q(mu))  !!!! attention
      enddo


      do nu=0,3

         j12t(nu)=(lambda0*dotcc(k,v3t)*dotcc(k2,v1t)*k1(nu) +
     $        dotcc(v1t,v3t)*((-MW2 + lambda0*dotcc(k1,k2))
     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*k1(nu)) +
     $        MW2*dotcc(k,v3t)*v1t(nu) -lambda0*dotcc(k,v3t)
     $        *dotcc(k1,k2)*v1t(nu) - MW2*dotcc(k2,v3t)*v1t(nu)
     $        - aDkappa0*MW2*dotcc(k2,v3t)*v1t(nu)
     $        +lambda0*dotcc(k,k1)*dotcc(k2,v3t)*v1t(nu) + MW2
     $        *dotcc(k2,v1t)*v3t(nu) + aDkappa0*MW2
     $        *dotcc(k2,v1t)*v3t(nu) -lambda0*dotcc(k,k1)*dotcc(k2
     $        ,v1t)*v3t(nu) - dotcc(k1,v1t)*(lambda0*dotcc(k2,v3t)
     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*v3t(nu)))
     $        /MW2

      enddo
      

         gs = -g/s

         jvv(1) = gs*j12t(0)
         jvv(2) = gs*j12t(1)
         jvv(3) = gs*j12t(2)
         jvv(4) = gs*j12t(3)

c
      return
      end


      subroutine jvvxxx_anomwaj02(v1,v2,g,vmass,vwidth , jvv)
c
c This subroutine computes an off-shell vector current from the three-
c point gauge boson coupling.  The vector propagator is given in Feynman
c gauge for a massless vector and in unitary gauge for a massive vector.
c
c input:
c       complex v1(6)          : first  vector                        v1
c       complex v2(6)          : second vector                        v2
c       real    g              : coupling constant (see the table below)
c       real    vmass          : mass  of output vector v
c       real    vwidth         : width of output vector v
c
c the possible sets of the inputs are as follows:
c    ------------------------------------------------------------------
c    |   v1   |   v2   |  jvv   |      g       |   vmass  |  vwidth   |
c    ------------------------------------------------------------------
c    |   W-   |   W+   |  A/Z   |  gwwa/gwwz   | 0./zmass | 0./zwidth |
c    | W3/A/Z |   W-   |  W+    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    |   W+   | W3/A/Z |  W-    | gw/gwwa/gwwz |   wmass  |  wwidth   |
c    ------------------------------------------------------------------
c where all the bosons are defined by the flowing-OUT quantum number.
c
c output:
c       complex jvv(6)         : vector current            j^mu(v:v1,v2)
c     
      implicit none
      integer mu,nu
      double complex v1(6),v2(6),jvv(6),j12(0:3),j12t(0:3),v1t(0:3),
     &    k(0:3),k1(0:3),k2(0:3),v3t(0:3)
      double complex sv1,sv2,v12,dotcc
      double complex cm2        ! mass**2- I Gamma mass (Fabio)
      double precision p1(0:3),p2(0:3),q(0:3),g,vmass,vwidth,gs,s,wgam2
      double precision vm2

      double precision rZero
      parameter( rZero = 0.0d0 )
      external dotcc 

      double precision formfactorkappaA, formfactorlambda

#include "VBFNLO/utilities/an_couplings.inc"
#include "VBFNLO/utilities/mssm.inc"

      jvv(5) = v1(5)+v2(5)
      jvv(6) = v1(6)+v2(6)

      p1(0) =  dble( v1(5))
      p1(1) =  dble( v1(6))
      p1(2) =  dimag(v1(6))
      p1(3) =  dimag(v1(5))
      p2(0) =  dble( v2(5))
      p2(1) =  dble( v2(6))
      p2(2) =  dimag(v2(6))
      p2(3) =  dimag(v2(5))
      q(0)  = -dble( jvv(5))
      q(1)  = -dble( jvv(6))
      q(2)  = -dimag(jvv(6))
      q(3)  = -dimag(jvv(5))
      s = q(0)**2-(q(1)**2+q(2)**2+q(3)**2)
      vm2 = vmass**2


!      print*, "naomal",p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)

      formfactorkappaA=1d0
      formfactorlambda=1d0

      if(formfact) then


!     W(p1) -> W(p2) gamma(nu)

         wgam2=p1(0)**2-(p1(1)**2+p1(2)**2+p1(3)**2)
         formfactorlambda=1d0/(1d0+wgam2/massscale2L)**ffexpL
         
         if (trianom .eq. 1) then
            formfactorkappaA = ((FB_0/(1d0+wgam2/
     -           massscale2FB)**ffexpFB) + (FW_0/(1d0+wgam2/
     -           massscale2FW)**ffexpFW))/(FB_0+FW_0)
         else if (trianom .eq. 2) then
            formfactorkappaA = 1d0/(1d0+wgam2/
     -           massscale2KA)**ffexpKA
         end if

      endif

      aDkappa0=-aDkappa0_0*formfactorkappaA
      lambda0=lambda0_0*formfactorlambda

      v12 = v1(1)*v2(1)-v1(2)*v2(2)-v1(3)*v2(3)-v1(4)*v2(4)
      sv1 =   (p2(0)-q(0))*v1(1) -(p2(1)-q(1))*v1(2)
     &      - (p2(2)-q(2))*v1(3) -(p2(3)-q(3))*v1(4)
      sv2 = - (p1(0)-q(0))*v2(1) +(p1(1)-q(1))*v2(2)
     &      + (p1(2)-q(2))*v2(3) +(p1(3)-q(3))*v2(4)
      j12(0) = (p1(0)-p2(0))*v12 +sv1*v2(1) +sv2*v1(1)
      j12(1) = (p1(1)-p2(1))*v12 +sv1*v2(2) +sv2*v1(2)
      j12(2) = (p1(2)-p2(2))*v12 +sv1*v2(3) +sv2*v1(3)
      j12(3) = (p1(3)-p2(3))*v12 +sv1*v2(4) +sv2*v1(4)

      do mu=0,3
      v1t(mu)=v2(mu+1)
      v3t(mu)=v1(mu+1)
      k(mu)=dcmplx(p2(mu))
      k1(mu)=dcmplx(p1(mu)) !!!! attention
      k2(mu)=dcmplx(q(mu))  !!!! attention
      enddo


      do nu=0,3

         j12t(nu)=(lambda0*dotcc(k,v3t)*dotcc(k2,v1t)*k1(nu) +
     $        dotcc(v1t,v3t)*((-MW2 + lambda0*dotcc(k1,k2))
     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*k1(nu)) +
     $        MW2*dotcc(k,v3t)*v1t(nu) -lambda0*dotcc(k,v3t)
     $        *dotcc(k1,k2)*v1t(nu) - MW2*dotcc(k2,v3t)*v1t(nu)
     $        - aDkappa0*MW2*dotcc(k2,v3t)*v1t(nu)
     $        +lambda0*dotcc(k,k1)*dotcc(k2,v3t)*v1t(nu) + MW2
     $        *dotcc(k2,v1t)*v3t(nu) + aDkappa0*MW2
     $        *dotcc(k2,v1t)*v3t(nu) -lambda0*dotcc(k,k1)*dotcc(k2
     $        ,v1t)*v3t(nu) - dotcc(k1,v1t)*(lambda0*dotcc(k2,v3t)
     $        *k(nu) + (MW2 - lambda0*dotcc(k,k2))*v3t(nu)))
     $        /MW2

      enddo
      

         gs = -g/s

         jvv(1) = gs*j12t(0)
         jvv(2) = gs*j12t(1)
         jvv(3) = gs*j12t(2)
         jvv(4) = gs*j12t(3)

c
      return
      end



